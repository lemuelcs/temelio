// backend/src/controllers/disponibilidade.controller.ts
// VERSÃO FINAL CORRIGIDA: usuarioId -> motoristaId em todos os métodos necessários

import { Request, Response } from 'express';
import { prisma } from '../lib/prisma';
import { startOfDay, endOfDay, parseISO, startOfWeek, endOfWeek, addWeeks, addDays, format } from 'date-fns';
import { ptBR } from 'date-fns/locale';
import { CicloRota, Prisma } from '@prisma/client';

// Type para disponibilidade com motorista incluído
type DisponibilidadeComMotorista = Prisma.DisponibilidadeGetPayload<{
  include: {
    motorista: {
      select: {
        id: true;
        nomeCompleto: true;
        tipoVeiculo: true;
        email: true;
        telefone: true;
        nivel: true;
        pontuacao: true;
      }
    }
  }
}>;

/**
 * Helper: Buscar motoristaId a partir do usuarioId
 */
async function getMotoristaIdFromUser(usuarioId: string): Promise<string | null> {
  const motorista = await prisma.motorista.findUnique({
    where: { usuarioId },
    select: { id: true }
  });
  return motorista?.id || null;
}

class DisponibilidadeController {
  
  /**
   * Listar todas as disponibilidades com filtros
   * Endpoint: GET /api/disponibilidades
   * Acesso: DESPACHANTE_PLANEJADOR, ADMINISTRADOR
   */
  async listarTodas(req: Request, res: Response) {
    try {
      const { dataInicio, dataFim, motoristaId, ciclo, disponivel } = req.query;

      // Construir filtros
      const where: Prisma.DisponibilidadeWhereInput = {};

      // Filtro de data
      if (dataInicio && dataFim) {
        where.data = {
          gte: startOfDay(parseISO(dataInicio as string)),
          lte: endOfDay(parseISO(dataFim as string))
        };
      } else if (dataInicio) {
        where.data = {
          gte: startOfDay(parseISO(dataInicio as string))
        };
      } else if (dataFim) {
        where.data = {
          lte: endOfDay(parseISO(dataFim as string))
        };
      }

      // Filtro de motorista
      if (motoristaId) {
        where.motoristaId = motoristaId as string;
      }

      // Filtro de ciclo
      if (ciclo) {
        where.ciclo = ciclo as CicloRota;
      }

      // Filtro de disponível
      if (disponivel !== undefined) {
        where.disponivel = disponivel === 'true';
      }

      // Buscar disponibilidades com dados do motorista
      const disponibilidades = await prisma.disponibilidade.findMany({
        where,
        include: {
          motorista: {
            select: {
              id: true,
              nomeCompleto: true,
              tipoVeiculo: true,
              email: true,
              nivel: true,
              pontuacao: true
            }
          }
        },
        orderBy: [
          { data: 'asc' },
          { ciclo: 'asc' }
        ]
      }) as any;

      // Formatar resposta
      const disponibilidadesFormatadas = disponibilidades.map((d: any) => ({
        id: d.id,
        motoristaId: d.motoristaId,
        data: d.data,
        ciclo: d.ciclo,
        disponivel: d.disponivel,
        motorista: {
          nome: d.motorista.nomeCompleto,
          tipoVeiculo: d.motorista.tipoVeiculo,
          nivel: d.motorista.nivel || null,
          pontuacao: d.motorista.pontuacao
        }
      }));

      return res.json({
        success: true,
        data: {
          disponibilidades: disponibilidadesFormatadas,
          total: disponibilidades.length
        }
      });

    } catch (error: any) {
      console.error('Erro ao listar disponibilidades:', error);
      return res.status(500).json({
        success: false,
        message: 'Erro ao listar disponibilidades',
        error: error.message
      });
    }
  }

  /**
   * Buscar resumo consolidado
   * Endpoint: GET /api/disponibilidades/resumo
   */
  async buscarResumo(req: Request, res: Response) {
    try {
      const { dataInicio, dataFim } = req.query;

      if (!dataInicio || !dataFim) {
        return res.status(400).json({
          success: false,
          message: 'dataInicio e dataFim são obrigatórios'
        });
      }

      // Buscar todas disponibilidades no período
      const disponibilidades = await prisma.disponibilidade.findMany({
        where: {
          data: {
            gte: startOfDay(parseISO(dataInicio as string)),
            lte: endOfDay(parseISO(dataFim as string))
          },
          disponivel: true
        },
        include: {
          motorista: {
            select: {
              id: true,
              nomeCompleto: true,
              tipoVeiculo: true,
              nivel: true,
              pontuacao: true
            }
          }
        }
      }) as any;

      // Agrupar por data, ciclo e tipo de veículo
      const resumo: Record<string, Record<string, Record<string, {
        count: number;
        motoristas: Array<{
          id: string;
          nome: string;
          nivel?: string | null;
          pontuacao?: number;
        }>;
      }>>> = {};

      disponibilidades.forEach((d: any) => {
        const dataKey = d.data.toISOString().split('T')[0];
        const ciclo = d.ciclo;
        const tipoVeiculo = d.motorista.tipoVeiculo;

        if (!resumo[dataKey]) {
          resumo[dataKey] = {};
        }
        if (!resumo[dataKey][ciclo]) {
          resumo[dataKey][ciclo] = {};
        }
        if (!resumo[dataKey][ciclo][tipoVeiculo]) {
          resumo[dataKey][ciclo][tipoVeiculo] = {
            count: 0,
            motoristas: []
          };
        }

        resumo[dataKey][ciclo][tipoVeiculo].count++;
        resumo[dataKey][ciclo][tipoVeiculo].motoristas.push({
          id: d.motorista.id,
          nome: d.motorista.nomeCompleto,
          nivel: d.motorista.nivel || null,
          pontuacao: d.motorista.pontuacao
        });
      });

      return res.json({
        success: true,
        data: {
          resumo,
          periodo: {
            inicio: dataInicio,
            fim: dataFim
          }
        }
      });

    } catch (error: any) {
      console.error('Erro ao buscar resumo:', error);
      return res.status(500).json({
        success: false,
        message: 'Erro ao buscar resumo de disponibilidades',
        error: error.message
      });
    }
  }

  /**
   * Buscar disponibilidades do motorista logado
   * Endpoint: GET /api/disponibilidades/minhas
   * CORRIGIDO: usuarioId -> motoristaId
   */
  async minhasDisponibilidades(req: Request, res: Response) {
    try {
      const usuarioId = (req as any).user?.id;

      if (!usuarioId) {
        return res.status(401).json({
          success: false,
          message: 'Usuário não autenticado'
        });
      }

      const motoristaId = await getMotoristaIdFromUser(usuarioId);

      if (!motoristaId) {
        return res.status(404).json({
          success: false,
          message: 'Motorista não encontrado para este usuário'
        });
      }

      const { dataInicio, dataFim } = req.query;

      const where: Prisma.DisponibilidadeWhereInput = {
        motoristaId
      };

      if (dataInicio && dataFim) {
        where.data = {
          gte: startOfDay(parseISO(dataInicio as string)),
          lte: endOfDay(parseISO(dataFim as string))
        };
      }

      const disponibilidades = await prisma.disponibilidade.findMany({
        where,
        orderBy: [
          { data: 'asc' },
          { ciclo: 'asc' }
        ]
      });

      return res.json({
        success: true,
        data: {
          disponibilidades
        }
      });

    } catch (error: any) {
      console.error('Erro ao buscar minhas disponibilidades:', error);
      return res.status(500).json({
        success: false,
        message: 'Erro ao buscar disponibilidades',
        error: error.message
      });
    }
  }

  /**
   * Buscar semana corrente + próxima semana
   * Endpoint: GET /api/disponibilidades/semanas
   * CORRIGIDO: usuarioId -> motoristaId
   */
  async buscarSemanas(req: Request, res: Response) {
    try {
      const usuarioId = (req as any).user?.id;

      if (!usuarioId) {
        return res.status(401).json({
          success: false,
          message: 'Usuário não autenticado'
        });
      }

      const motoristaId = await getMotoristaIdFromUser(usuarioId);

      if (!motoristaId) {
        return res.status(404).json({
          success: false,
          message: 'Motorista não encontrado para este usuário'
        });
      }

      // Calcular datas (semana atual + próxima)
      const hoje = new Date();
      const inicioSemanaAtual = startOfWeek(hoje, { weekStartsOn: 0 }); // Domingo
      const fimSemanaAtual = endOfWeek(hoje, { weekStartsOn: 0 }); // Sábado
      
      const inicioProximaSemana = addWeeks(inicioSemanaAtual, 1);
      const fimProximaSemana = endOfWeek(inicioProximaSemana, { weekStartsOn: 0 });

      // Buscar disponibilidades da semana atual
      const semanaAtual = await prisma.disponibilidade.findMany({
        where: {
          motoristaId,
          data: {
            gte: startOfDay(inicioSemanaAtual),
            lte: endOfDay(fimSemanaAtual)
          }
        },
        orderBy: [
          { data: 'asc' },
          { ciclo: 'asc' }
        ]
      });
      // ADICIONE ESTES LOGS AQUI:
      console.log('🔎 Buscando semana atual:', {
        motoristaId,
        de: startOfDay(inicioSemanaAtual),
        ate: endOfDay(fimSemanaAtual),
        encontrados: semanaAtual.length
      });
      console.log('📊 Disponibilidades encontradas:', semanaAtual);

      // Buscar disponibilidades da próxima semana
      const proximaSemana = await prisma.disponibilidade.findMany({
        where: {
          motoristaId,
          data: {
            gte: startOfDay(inicioProximaSemana),
            lte: endOfDay(fimProximaSemana)
          }
        },
        orderBy: [
          { data: 'asc' },
          { ciclo: 'asc' }
        ]
      });

      return res.json({
        success: true,
        data: {
          semanaCorrente: {
            disponibilidades: semanaAtual,
            periodo: {
              inicio: format(inicioSemanaAtual, 'yyyy-MM-dd'),
              fim: format(fimSemanaAtual, 'yyyy-MM-dd')
            }
          },
          proximaSemana: {
            disponibilidades: proximaSemana,
            periodo: {
              inicio: format(inicioProximaSemana, 'yyyy-MM-dd'),
              fim: format(fimProximaSemana, 'yyyy-MM-dd')
            }
          }
        }
      });

    } catch (error: any) {
      console.error('Erro ao buscar semanas:', error);
      return res.status(500).json({
        success: false,
        message: 'Erro ao buscar semanas',
        error: error.message
      });
    }
  }

  /**
   * Cadastrar disponibilidades em lote
   * Endpoint: POST /api/disponibilidades/batch
   * CORRIGIDO: usuarioId -> motoristaId + validações + logs
   */
  async cadastrarBatch(req: Request, res: Response) {
    try {
      const usuarioId = (req as any).user?.id;
      const { disponibilidades } = req.body;

      console.log('📥 Recebido no backend:', {
        usuarioId,
        qtd: disponibilidades?.length,
        primeira: disponibilidades?.[0]
      });

      if (!usuarioId) {
        return res.status(401).json({
          success: false,
          message: 'Usuário não autenticado'
        });
      }

      // Buscar motorista associado ao usuário
      const motorista = await prisma.motorista.findUnique({
        where: { usuarioId },
        select: { id: true, nomeCompleto: true }
      });

      console.log('👤 Motorista encontrado:', motorista);

      if (!motorista) {
        return res.status(404).json({
          success: false,
          message: 'Motorista não encontrado para este usuário'
        });
      }

      const motoristaId = motorista.id;

      if (!Array.isArray(disponibilidades) || disponibilidades.length === 0) {
        return res.status(400).json({
          success: false,
          message: 'Nenhuma disponibilidade fornecida'
        });
      }

      // Validar e preparar dados
      const novasDisponibilidades = disponibilidades.map((d, index) => {
        //const dataParsed = parseISO(d.data);
        const dataParsed = new Date(d.data + 'T00:00:00.000Z');
        
        if (index === 0) {
          console.log('🔍 Primeira disponibilidade:', {
            original: d,
            dataParsed,
            dataValida: !isNaN(dataParsed.getTime()),
            startOfDay: startOfDay(dataParsed)
          });
        }

        // Validar se a data é válida
        if (isNaN(dataParsed.getTime())) {
          console.error('❌ Data inválida:', d.data);
          throw new Error(`Data inválida: ${d.data}`);
        }

        return {
          motoristaId,
          data: dataParsed,
          ciclo: d.ciclo as CicloRota,
          disponivel: d.disponivel
        };
      });

      console.log('✅ Preparado para salvar:', {
        motoristaId,
        motoristaNome: motorista.nomeCompleto,
        qtd: novasDisponibilidades.length,
        primeira: novasDisponibilidades[0]
      });

      // Deletar disponibilidades antigas do mesmo período
      const datas = novasDisponibilidades.map(d => d.data);
      const dataMin = new Date(Math.min(...datas.map(d => d.getTime())));
      const dataMax = new Date(Math.max(...datas.map(d => d.getTime())));

      console.log('🗑️  Deletando período:', {
        de: startOfDay(dataMin),
        ate: endOfDay(dataMax)
      });

      const deletados = await prisma.disponibilidade.deleteMany({
        where: {
          motoristaId,
          data: {
            gte: dataMin,
            lte: dataMax
          }
        }
      });

      console.log('🗑️  Deletados:', deletados.count);

      // Inserir novas disponibilidades
      console.log('💾 Inserindo...');
      const resultado = await prisma.disponibilidade.createMany({
        data: novasDisponibilidades
      });

      console.log('✅ Salvo com sucesso:', resultado.count);

      return res.json({
        success: true,
        message: 'Disponibilidades salvas com sucesso',
        data: {
          count: resultado.count
        }
      });

    } catch (error: any) {
      console.error('❌ Erro ao cadastrar batch:', error);
      return res.status(500).json({
        success: false,
        message: 'Erro ao salvar disponibilidades',
        error: error.message
      });
    }
  }

  /**
   * Alias para cadastrarBatch (compatibilidade com rotas antigas)
   * Endpoint: POST /api/motoristas/:id/disponibilidades/batch
   */
  async salvarDisponibilidadesBatch(req: Request, res: Response) {
    return this.cadastrarBatch(req, res);
  }

  /**
   * Cadastrar disponibilidade individual
   * Endpoint: POST /api/disponibilidades
   * CORRIGIDO: usuarioId -> motoristaId
   */
  async cadastrar(req: Request, res: Response) {
    try {
      const usuarioId = (req as any).user?.id;
      const { data, ciclo, disponivel } = req.body;

      if (!usuarioId) {
        return res.status(401).json({
          success: false,
          message: 'Usuário não autenticado'
        });
      }

      const motoristaId = await getMotoristaIdFromUser(usuarioId);

      if (!motoristaId) {
        return res.status(404).json({
          success: false,
          message: 'Motorista não encontrado para este usuário'
        });
      }

      const disponibilidade = await prisma.disponibilidade.create({
        data: {
          motoristaId,
          data: parseISO(data),
          ciclo: ciclo as CicloRota,
          disponivel
        }
      });

      return res.json({
        success: true,
        data: { disponibilidade }
      });

    } catch (error: any) {
      console.error('Erro ao cadastrar disponibilidade:', error);
      return res.status(500).json({
        success: false,
        message: 'Erro ao cadastrar disponibilidade',
        error: error.message
      });
    }
  }

  /**
   * Atualizar disponibilidade
   * Endpoint: PUT /api/disponibilidades/:id
   * CORRIGIDO: usuarioId -> motoristaId
   */
  async atualizar(req: Request, res: Response) {
    try {
      const { id } = req.params;
      const usuarioId = (req as any).user?.id;
      const { disponivel } = req.body;

      if (!usuarioId) {
        return res.status(401).json({
          success: false,
          message: 'Usuário não autenticado'
        });
      }

      const motoristaId = await getMotoristaIdFromUser(usuarioId);

      if (!motoristaId) {
        return res.status(404).json({
          success: false,
          message: 'Motorista não encontrado para este usuário'
        });
      }

      // Verificar se a disponibilidade pertence ao motorista
      const disponibilidadeExistente = await prisma.disponibilidade.findUnique({
        where: { id }
      });

      if (!disponibilidadeExistente) {
        return res.status(404).json({
          success: false,
          message: 'Disponibilidade não encontrada'
        });
      }

      if (disponibilidadeExistente.motoristaId !== motoristaId) {
        return res.status(403).json({
          success: false,
          message: 'Você não tem permissão para editar esta disponibilidade'
        });
      }

      const disponibilidade = await prisma.disponibilidade.update({
        where: { id },
        data: { disponivel }
      });

      return res.json({
        success: true,
        data: { disponibilidade }
      });

    } catch (error: any) {
      console.error('Erro ao atualizar disponibilidade:', error);
      return res.status(500).json({
        success: false,
        message: 'Erro ao atualizar disponibilidade',
        error: error.message
      });
    }
  }

  /**
   * Excluir disponibilidade
   * Endpoint: DELETE /api/disponibilidades/:id
   * CORRIGIDO: usuarioId -> motoristaId
   */
  async excluir(req: Request, res: Response) {
    try {
      const { id } = req.params;
      const usuarioId = (req as any).user?.id;

      if (!usuarioId) {
        return res.status(401).json({
          success: false,
          message: 'Usuário não autenticado'
        });
      }

      const motoristaId = await getMotoristaIdFromUser(usuarioId);

      if (!motoristaId) {
        return res.status(404).json({
          success: false,
          message: 'Motorista não encontrado para este usuário'
        });
      }

      const disponibilidadeExistente = await prisma.disponibilidade.findUnique({
        where: { id }
      });

      if (!disponibilidadeExistente) {
        return res.status(404).json({
          success: false,
          message: 'Disponibilidade não encontrada'
        });
      }

      if (disponibilidadeExistente.motoristaId !== motoristaId) {
        return res.status(403).json({
          success: false,
          message: 'Você não tem permissão para excluir esta disponibilidade'
        });
      }

      await prisma.disponibilidade.delete({
        where: { id }
      });

      return res.json({
        success: true,
        message: 'Disponibilidade excluída com sucesso'
      });

    } catch (error: any) {
      console.error('Erro ao excluir disponibilidade:', error);
      return res.status(500).json({
        success: false,
        message: 'Erro ao excluir disponibilidade',
        error: error.message
      });
    }
  }

  /**
   * Buscar disponibilidades por motorista
   * Endpoint: GET /api/disponibilidades/motorista/:motoristaId
   */
  async buscarPorMotorista(req: Request, res: Response) {
    try {
      const { motoristaId } = req.params;
      const { dataInicio, dataFim } = req.query;

      const where: Prisma.DisponibilidadeWhereInput = { motoristaId };

      if (dataInicio && dataFim) {
        where.data = {
          gte: startOfDay(parseISO(dataInicio as string)),
          lte: endOfDay(parseISO(dataFim as string))
        };
      }

      const disponibilidades = await prisma.disponibilidade.findMany({
        where,
        orderBy: [
          { data: 'asc' },
          { ciclo: 'asc' }
        ]
      });

      return res.json({
        success: true,
        data: { disponibilidades }
      });

    } catch (error: any) {
      console.error('Erro ao buscar por motorista:', error);
      return res.status(500).json({
        success: false,
        message: 'Erro ao buscar disponibilidades',
        error: error.message
      });
    }
  }

  /**
   * Buscar motoristas disponíveis
   * Endpoint: POST /api/disponibilidades/buscar-motoristas
   */
  async buscarMotoristasDisponiveis(req: Request, res: Response) {
    try {
      const { data, ciclo, tipoVeiculo } = req.body;

      if (!data || !ciclo) {
        return res.status(400).json({
          success: false,
          message: 'data e ciclo são obrigatórios'
        });
      }

      const where: Prisma.DisponibilidadeWhereInput = {
        data: startOfDay(parseISO(data)),
        ciclo: ciclo as CicloRota,
        disponivel: true
      };

      if (tipoVeiculo) {
        where.motorista = {
          tipoVeiculo
        };
      }

      const disponibilidades = await prisma.disponibilidade.findMany({
        where,
        include: {
          motorista: {
            select: {
              id: true,
              nomeCompleto: true,
              tipoVeiculo: true,
              email: true,
              nivel: true,
              pontuacao: true
            }
          }
        },
        orderBy: {
          motorista: {
            pontuacao: 'desc' // Ordenar por pontuação (Elite primeiro)
          }
        }
      }) as any;

      const motoristas = disponibilidades.map((d: any) => d.motorista);

      return res.json({
        success: true,
        data: {
          motoristas,
          total: motoristas.length
        }
      });

    } catch (error: any) {
      console.error('Erro ao buscar motoristas disponíveis:', error);
      return res.status(500).json({
        success: false,
        message: 'Erro ao buscar motoristas disponíveis',
        error: error.message
      });
    }
  }

  /**
   * Buscar histórico
   * Endpoint: GET /api/disponibilidades/historico
   * CORRIGIDO: usuarioId -> motoristaId
   */
  async buscarHistorico(req: Request, res: Response) {
    try {
      const usuarioId = (req as any).user?.id;

      if (!usuarioId) {
        return res.status(401).json({
          success: false,
          message: 'Usuário não autenticado'
        });
      }

      const motoristaId = await getMotoristaIdFromUser(usuarioId);

      if (!motoristaId) {
        return res.status(404).json({
          success: false,
          message: 'Motorista não encontrado para este usuário'
        });
      }

      const { dataInicio, dataFim } = req.query;

      const where: Prisma.DisponibilidadeWhereInput = {
        motoristaId
      };

      if (dataInicio && dataFim) {
        where.data = {
          gte: startOfDay(parseISO(dataInicio as string)),
          lte: endOfDay(parseISO(dataFim as string))
        };
      }

      // Buscar disponibilidades
      const disponibilidades = await prisma.disponibilidade.findMany({
        where,
        orderBy: {
          updatedAt: 'desc'
        },
        take: 100
      });

      // Calcular estatísticas
      const totalSlots = disponibilidades.length;
      const slotsDisponiveis = disponibilidades.filter(d => d.disponivel).length;
      const taxaDisponibilidade = totalSlots > 0 
        ? ((slotsDisponiveis / totalSlots) * 100).toFixed(1) 
        : '0';

      return res.json({
        success: true,
        data: {
          historico: disponibilidades,
          estatisticas: {
            totalSlots,
            slotsDisponiveis,
            slotsIndisponiveis: totalSlots - slotsDisponiveis,
            taxaDisponibilidade: `${taxaDisponibilidade}%`
          }
        }
      });

    } catch (error: any) {
      console.error('Erro ao buscar histórico:', error);
      return res.status(500).json({
        success: false,
        message: 'Erro ao buscar histórico',
        error: error.message
      });
    }
  }
}

// Instanciar controller
const controller = new DisponibilidadeController();

// Exportações nomeadas para compatibilidade com rotas
export const listarTodas = controller.listarTodas.bind(controller);
export const buscarResumo = controller.buscarResumo.bind(controller);
export const minhasDisponibilidades = controller.minhasDisponibilidades.bind(controller);
export const buscarSemanas = controller.buscarSemanas.bind(controller);
export const cadastrarBatch = controller.cadastrarBatch.bind(controller);
export const salvarDisponibilidadesBatch = controller.salvarDisponibilidadesBatch.bind(controller);
export const cadastrar = controller.cadastrar.bind(controller);
export const atualizar = controller.atualizar.bind(controller);
export const excluir = controller.excluir.bind(controller);
export const buscarPorMotorista = controller.buscarPorMotorista.bind(controller);
export const buscarMotoristasDisponiveis = controller.buscarMotoristasDisponiveis.bind(controller);
export const buscarHistorico = controller.buscarHistorico.bind(controller);

// Export default para compatibilidade
export default controller;